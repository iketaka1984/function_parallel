
\documentclass[submit,PRO]{ipsj}
%\documentclass{ipsj}

\usepackage{PROpresentation}
\PROheadtitle{y-n-(x): 情報処理学会プログラミング研究会 発表資料 Y年m月d日}

\usepackage[dvipdfmx]{graphicx}
\usepackage{latexsym}

%%%begin yuen
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[cmtip,all]{xy}
\newcommand{\longsquiggly}{\xymatrix{{}\ar@{~>}[r]&{}}}
\newtheorem{thm}{定理}
\newtheorem{defn}[thm]{定義}
\newcommand{\bcode}[1]{$\mathsf{#1}$}
\newcommand{\brightarrow}[1]{\stackrel{#1}{\rightsquigarrow}}
%%%end yuen

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}
\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}
\def\|{\verb|}

\setcounter{巻数}{59}
\setcounter{号数}{1}
\setcounter{page}{1}


\受付{2016}{3}{4}
%\再受付{2015}{7}{16}   %省略可能
%\再再受付{2015}{7}{20} %省略可能
%\再再受付{2015}{11}{20} %省略可能
\採録{2016}{8}{1}




\begin{document}


\title{再帰的ブロック構造を持つ並列プログラムに対する\\
      可逆実行環境}

\etitle{A reversible runtime for parallel programs with recursive blocks}

\affiliate{NUniv}{名古屋大学情報学研究科\\
Graduate school of imformatics, Nagoya University,\\
Furo-cho, Chikusa-ward, Nagoya-city, 464-8601}



\author{池田 崇志}{Takashi Ikeda}{NUniv}[tikeda@sqlab.jp]
\author{結縁 祥治}{Shoji Yuen}{NUniv}[yuen@sqlab.jp]


\begin{abstract}
本論文では，並列に実行されるブロック構造を持つプログラムの実行を解
析することを目的として可逆実行環境の実装を示す．並列プログラムを抽象
機械の３番地コードに変換して実行する．順方向の実行時は逆向き実行に必
要な情報をスタックに保存し，その実行を逆向きに辿る実行環境を実装す
る．この実行環境では，順方向の抽象命令を逆方向の抽象命令に一対一に変
換することで逆向き実行を実現する．

抽象命令の変換による実行環境[T.Ikeda and S.Yuen, 2020] では，並列実
行において抽象機械をPython のmultiprocessing モジュールでフォークす
る抽象命令を実装し，順方向および逆方向において並列実行する実行環境を
示した．

ここでは，実際的なプログラムの構文要素として，ブロック構造，手続き
呼び出し，関数呼び出しを含むように拡張した．Hoey らの手法に従って変
数のスコープを扱うために，各ブロックに名前を付け，参照情報をパスとし
て表し，局所変数を実現する．本研究で新たに提案する方法として抽象命令
生成時に作成する並列ブロックの開始及び終了番地を記録したテーブルを用
いて並列ブロックを起動することにより順方向，逆方向ともに並列の入れ子
構造を実現する．これらの実現手法によって，ブロック構造を持つプログラ
ミング言語に対して単純な抽象機械の実行メカニズムによって逆方向実行が
可能となることを示し，並列プログラムのデバッグのための基盤として提案
する．
\end{abstract}


\begin{jkeyword}
a
\end{jkeyword}

\begin{eabstract}
This paper presents a reversible runtime of simple parallel programs
with blocks.  A program is translated into a sequence of three-address
abstract machine instructions and abstract machines running in
parallel execute the instructions.  The runtime stores the information
of variable updates and program counter jumps associated with process
identifies on stacks in the forward execution. In the backward
execution, the abstract instructions for forward execution are
converted to reverse abstract instructions one-to-one.

In our previous work, we presented a runtime for parallel programs with
flat-fixed structures.  The runtime executes multiple abstract
machines using the multiprocessing module of Python.

This work extends the runtime for practical language features,
including blocks, procedure-call, and function-call. To deal with the
scope of variables in blocks, we assign the path information with
block names following Hoey et.al.  Besides variable paths, the runtime
records the invocation history of parallel blocks as a table to
reverse the invocation of parallel blocks.  We realize parallel nested
structures in both directions.  We illustrate that executing abstract
machines makes bi-directional execution simple even with the recursive
structure of blocks.  We propose them as a foundation for behavioural
analysis such as debugging.

\end{eabstract}

\begin{ekeyword}
a
\end{ekeyword}

\maketitle

%1
\section{はじめに}

可逆計算に基づいたプログラムの逆実行は、プログラムの振舞いの解析において
有用な手がかりを与える。プログラムを順方向に実行し、初期状態から最終状態
に至る状態遷移系列によって、初期状態における入力から最終状態おける出力を
得る。デバッグなどの場合にプログラムの振舞いを解析する場合、計算過程の途
中でどのようにプログラムの状態が変化したのかということを詳細に追跡する必
要が生じる。順方向実行では、出力を計算するための情報が保持され、出力とし
て必要のない情報は捨てられることが多い。解析のためにはプログラムの振舞い
の履歴を残しておくことは有用であり、振舞いの解析のために必要な情報を残す
ことが望ましい。このため、解析のためにメモリの状態をすべてダンプしたり、
必要と思われるログ情報を残すことが行われる。この観点において、逆方向に実
行できるだけの情報があれば振舞いを特定することが容易となることが知られて
おり、このアイデアに基づいた可逆プログラミング言語が提案されている
\cite{Janus1,Janus2,RFUN}。Janusにおいては、条件分岐構文を拡張して条件分
岐がどの方向で発生したか逆方向から辿ることができ、最終状態からプログラム
を逆から実行して初期状態に至る振舞いを再現することができる。可逆計算に基
づいて必要十分の情報をプログラミング言語に組込むことによって効率的な解析
を行なうことができるようになる。

並列プログラムでは概念的に複数のプログラムブロックが同時に実行される。多
くの場合、並列の振舞いは共有変数を介したインターリーブによる並行実行で捉
えられる。このため、個々のプログラムブロックの実行履歴に加えて、複数のプ
ログラムブロックが全体としてどのように実行されたかという情報が必要になる。
並列プログラムの並行実行では実行順序の組み合わせが膨大になることから逆方
向の実行に必要な情報に限定することは有用である。Hoeyらは並列プログラムに
必要なアノテーションを付加することによって並列プログラムの可逆実行意味を
示している\cite{HIY18,H20}。ここでは必要な履歴情報をプログラムのアノテー
ションに基づいて保存することによって逆方向の並行実行を可能とし、逆方向の
実行によって初期状態まで戻る計算によってアノテーション情報が残らないこと
で、履歴情報が必要十分であることを示している。

ここでは並列プログラムの並行実行処理系が情報を保存することで逆方向の振舞
いを実現する方法について示す。筆者らは、大域変数のみをもつ単純な並列ブロッ
ク構造を持つプログラムに対する実行環境を抽象機械のバイトコードを定義する
ことで実現する方法を示した\cite{RC2020}。個々の抽象機械は局所スタックを
持ち、逐次的にバイトコードを実行する。並列ブロックの実行では、個々のブロッ
ク毎に抽象機械を生成して並列に実行する。大域的な実行情報として、共有変数
の更新情報(値スタック)とジャンプによる個々の抽象機械のプログラムカウンタ
の更新情報(ラベルスタック)を記録する。順方向計算は、入力値、空の値スタッ
ク、および空のラベルスタックから計算を開始し、出力値、値スタック、ラベル
スタックを与えて終了する。逆方向の計算は、出力値、値スタック、ラベルスタッ
クから開始して、もとの入力値と空の値スタックとラベルスタックで終了する。
逆方向の計算を実行するためのバイトコードは、順方向のバイトコードを
変換することによって得られる。

本発表では\cite{RC2020}の並列プログラミング言語を拡張し、再帰的な
手続き呼び出しを導入する。再帰的なブロック構造を許すことによって
動的な並列ブロックの逆方向実行を可能にする。実行環境にプログラムの
並列構造を示す構文的なテーブルを導入することによって実現する。
このメカニズムによって、逆方向から実行する際に抽象機械をどのように
生成すればよいかを知ることができる。手続に加えて関数についても
実現し、実用的なプログラミング言語の処理系において可逆計算を可能と
するために必要なメカニズムについて示す。さらに、実行環境をPython
のmultiprocessingモジュールを用いて実現し、バイトコードへの
変換器をJavaccを用いて実現した。

本発表の構成は以下の通りである。
2節において対象とする並列プログラミング言語を定義し、3節において
抽象機械とバイトコードを示す。4節において実現した実行環境について
説明する。5節で関連研究とまとめを示す。





%3
\section{並列プログラミング言語}

対象とする並列プログラミング言語はwhileループやif文，手続き呼び出しのブロック，関数呼び出しのブロック，および並列ブロックを持つプログラミング言語である．ソースプログラムを抽象機械命令に変換することで抽象機械によって実行する．並列ブロックはparから始まり，各ブロックを$||$の記号で区切り，rapで終わる．

%3.1
\subsection{対象言語の定義}
\label{sec:3.1}

\begin{figure}[tb]
\setbox0\vbox{
\hbox{$P ::= begin\ bn\ BB\ end$}
\hbox{\ \ \ \ \ \ \ $|$ par an $P(\parallel P)^+$ $rap$}
\hbox{\ \ \ \ \ \ \ $|$ $S$}
\hbox{$BB\ ::=\ DV\ DP\ DF\ P(;P)^+\ RV$}
\hbox{$S\ ::=\ skip\ |\  X = E\ |\ if\ C\ then\ P\ else\ P\ fi\ |$}
\hbox{$\ \ \ \ \ \ \ \ \ \  while\ wn\ C\ do\ P\ od\ |\ call\ cn\ a(X?)$}
\hbox{$DV\ ::=\ (var\ X;)^*$}
\hbox{$DP\ ::=\ (proc\ pn\ a(X?)\ is\ P\ end)^*$}
\hbox{$DF\ ::=\ (func\ fn\ b(X?)\ is\ P\ return)^*$}
\hbox{$RV\ ::=\ (remove\ X;)^*$}
\hbox{$E\ ::=\ X\ |\ n\ |\ (E)\ |\ E\ op\ E | \{cn\ b(X?)\}$}
\hbox{$C\ ::=\ B\ |\ C\ \&\& \ C\ |\ not\ C\ |\ (C)$}
\hbox{$B\ ::=\ E\ ==\ E\ |\ E\ >\ E$}
\hbox{\\}
\hbox{\| (X: 変数，n: 整数，a: 手続き名，b: 関数名，|}
\hbox{$op: \{+,-,\times \})$}
}
\centerline{\fbox{\box0}}
\caption{対象言語の定義}
\ecaption{definition of language}
\label{fig:def}
\end{figure}


対象言語の定義を\figref{fig:def}に示す．$bn,an,wn,pn,fn,cn$はそれぞれのブロック名を示す．それぞれnは整数値を表しb1,b2,...のように整数値の部分が重複しないとする．DVは変数の宣言，DPは手続きの宣言，DFは関数の宣言，RVは変数の解放を行うステートメントを示している．あるブロック内で宣言された変数はそのブロック内で必ず宣言した順番とは逆の順番で変数の解放を行うステートメントを記述する必要がある．

\begin{itemize}
\item
手続き呼び出し  手続きの宣言はprocから始まり，endで終わるように記述する．手続きの引数は変数一つのみとし，値を返すことはしない．callステートメントを記述することで宣言された手続きを呼び出し，その手続きを実行する．
\item
関数呼び出し  関数の宣言はfuncから始まり，returnで終わるように記述する．関数は簡単のため引数一つとする．関数内では関数の名前を返り値とする．関数の呼び出しは呼び出し名cnと関数名および引数を\{\}で囲って記述する．
\end{itemize}

\subsection{プログラム例}
\figref{fig:sample}にプログラム例を示す．ブロックb1内で変数の宣言，手続きのairlineの宣言を行い，メインの処理として変数の値割り当て，手続きairlineの呼び出しを行い，最後に最初に宣言した変数の解放を行うプログラムである．このプログラムは二つのagentが並列に動作してseatsを売っていく航空券販売のプログラムを表している．実際の動作について，6から15行目と16から25行目は並列に動作しseatsが0にならない限りseatsを減らしていく．しかし，9行目と18行目のseatsが0より大きいという条件判定が同時に行われてしまうとseatsが0であるのに-1を行いseatsの値が-1という望ましくない結果が得られることがある．これを実行する際に逆方向実行に必要な情報を残すことでこの実行を逆に辿りseatsの値が不正に更新された部分を探すことを考える．この実行を逆に辿っていくと10行目もしくは19行目に対応する実行でseatsの値が-1から0に戻される．これによってseatsが0より大きいという条件判定のもとseats=seats-1を実行するはずがseatsの値が既に0になってしまっていて不正に1引いてしてしまっている部分を特定することができる．



\begin{figure}[tb]
\setbox0\vbox{
\hbox{\| 1: begin b1|}
\hbox{\| 2:     var seats;|}
\hbox{\| 3:     var agent1;|}
\hbox{\| 4:     var agent2;|}
\hbox{\| 5:     proc p1 airline() is|}
\hbox{\| 6:         par a1 |}
\hbox{\| 7:             begin b2|}
\hbox{\| 8:                 while w1 (agent1==1) do|}
\hbox{\| 9:                     if (seats>0) then|}
\hbox{\|10:                        seats=seats-1|}
\hbox{\|11:                     else|}
\hbox{\|12:                         agent1=0|}
\hbox{\|13:                     fi|}
\hbox{\|14:                 od|}
\hbox{\|15:             end|}
\hbox{\|16:         |$||$\|  begin b3|}
\hbox{\|17:                 while w2 (agent2==1) do|}
\hbox{\|18:                     if (seats>0) then|}
\hbox{\|19:                         seats=seats-1|}
\hbox{\|20:                     else |}
\hbox{\|21:                         agent2=0|}
\hbox{\|22:                     fi|}
\hbox{\|23:                 od|}
\hbox{\|24:             end|}
\hbox{\|25:         rap|}
\hbox{\|26:     end|}
\hbox{\|27:     seats=3;|}
\hbox{\|28:     agent1=1;|}
\hbox{\|29:     agent2=1;|}
\hbox{\|30:     call c1 airline()|}
\hbox{\|31:     remove agent2;|}
\hbox{\|32:     remove agent1;|}
\hbox{\|33:     remove seats;|}
\hbox{\|34: end|}
}
\centerline{\fbox{\box0}}
\caption{プログラム例}
\ecaption{sample program}
\label{fig:sample}
\end{figure}



%4
\section{可逆実行環境}
\label{config}

本研究では先行研究\cite{HIY18,H20}を基に抽象機械命令のバイトコードを抽象機械で実行する．以前までに実装した可逆実行環境に対して新しく変数のスコープ，並列ブロックのネスト構造，手続き呼び出し及び関数呼び出しの拡張を行う．

ブロック構造に対する変数に対しては先行研究の手法を参考に各ブロックに名前を付け，参照構造を表すパスとすることで変数のスコープを実現する．

\subsection{順方向実行環境}

順方向の計算で用いるバイトコードセットを\tabref{tab:forwardinstruction}に示す．

\begin{figure}[tb]
\CaptionType{table}
\caption{順方向の抽象機械命令セット}
\ecaption{instruction of abstract machine for forward}
\label{tab:forwardinstruction}
\begin{center}
\begin{tabular}[t]{|c|c|c|}\hline
番号 & 命令 & 被演算子 \\\hline
1 & \bcode{ipush} & 即値 \\\hline
2 & \bcode{load} & 変数番地 \\\hline
3 & \bcode{store} &変数番地 \\\hline
4 & \bcode{jpc}&ジャンプ先PC \\\hline
5 & \bcode{jmp}&ジャンプ先PC \\\hline
6 & \bcode{op}&演算番号 \\\hline
7 & \bcode{label}&バイトコード全体の抽象命令数 \\\hline
8& \bcode{par}&\{0,1\} \\\hline
9& \bcode{alloc}&変数番地 \\\hline
10& \bcode{free}&変数番地 \\\hline
11& \bcode{proc}&pn \\\hline
12& \bcode{p\_return}&pn \\\hline
13& \bcode{block} & bn \\\hline
14& \bcode{end} & bn \\\hline
15& \bcode{fork} & an \\\hline
16& \bcode{merge} & an \\\hline
17& \bcode{func} & fn \\\hline
18& \bcode{f\_return} & fn \\\hline
19& \bcode{w\_label} & wn \\\hline
20& \bcode{w\_end} & wn \\\hline
21& \bcode{nop} & 0 \\\hline
\end{tabular}
\end{center}
\end{figure}

\subsubsection{順方向実行環境の概要}

\begin{itemize}
 \item ジャンプ履歴の保存\\
順方向の実行ではjmp命令のターゲットには必ずlabel命令を生成する。
label命令はどこからジャンプしてきたかというジャンプ履歴の保存を行う．
ラベルスタックにはプロセスIDとPCの値aを保存する．
label命令を実行した時のパスと実行したプロセスを繋
げたものもそのaと組にして保存する．
\item 変数更新履歴の保存\\
順方向の実行ではstore命令を実行する際に演算スタックのトップから値をポッ
プし共有変数スタックに値を保存する．その際に失われるはずのそれまでの変数
の値を値スタックに保存する．store命令を実行したときのパスと実行したプロ
セスを繋げたものもその値と組にして保存する．
\end{itemize}

%4.1.1
\subsubsection{変数のスコープ}

変数はalloc命令が実行される際に変数テーブルにその時点でのパスと変数の名
前を繋げて固有の変数名とした名前を記録する．free命令を実行する際に解放す
る変数の値を名前の一致する変数名と組にして保存する．

本発表では，ブロック構造を記述できるように対象言語を拡張する．そのため、
手続きブロック内で宣言される変数Xとその外で宣言される変数Xは別物として扱
う機能が必要である．そこで先行研究\cite{HIY18,H20}を参考にそれぞれのブロッ
クに名前を付け参照構造を保存するためにパスという機能を実装した．例えば，
ブロックb1内のブロックb2内の手続きブロックp1内はパスb1.b2.p1となり，参照
構造が明らかにわかるようになっている．そしてこの手続きブロックp1内で宣言
される変数Xはb1.b2.p1.Xと固有の名前を改めて付け以降はこの名前で扱う．
load命令などで変数Xを参照する場合はその時点のパスを内側から検索していき
最も近いパスと最後にXの名前がついている変数名の値を読み出す．

%4.1.2
\subsubsection{並列ブロック}

バイトコードにおいて一つの並列ブロックはfork命令から始まり，各ブロックが
{\sf par 0}，{\sf par 1}で囲まれ，\bcode{merge}命令で終わる．バイトコー
ドを作成する際に生成する並列テーブルはこの{\sf par 0}と{\sf par 1}の番地
を組にして保存し各ブロックの開始番地終了番地を保存している．\bcode{fork}
の被演算子は並列ブロック名 an である。ソースプログラムにおけるanに対する
並列ブロックテーブルを生成し，anに含まれる並列ブロックに対して，子プロセ
スとして生成するプロセスの命令開始番地と命令終了番地を示す静的なテーブル
$T$を生成する．

並列ブロックは，構成されるプログラムブロックが終了番地まで実行されて
すべて終了したときに終了し，実行が継続する．

\begin{figure}[tb]
\includegraphics[height=6.0cm,width=9.0cm]{parallel.eps}
\caption{並列プロセスの生成}
\ecaption{creating parallel process }
\label{fig:parallel}
\end{figure}


\figref{fig:parallel}に並列プロセスの生成を示している．forkによって並列プロセスが生成，起動され，さらに生成されたプロセスから並列プロセスが生成，起動されている．それぞれ生成されたプロセスはその実行が終了するとmergeで生成したプロセスに実行の制御を戻していく．

\figref{fig:parallel}の順方向の図と逆方向の図は実線と点線がそれぞれ対応しており順方向のfork，mergeはそれぞれ逆方向ではmerge，forkになる．このようにして順方向と同様の並列プロセスの生成を逆方向でも行う．

%4.1.3
\subsubsection{手続き呼び出しおよび関数呼び出し}

抽象機械において，手続きの振舞いは\bcode{proc}命令から\bcode{p\_return}
命令までのブロックで記述され，手続きの呼び出しはproc命令のPCにジャンプす
る\bcode{jmp}命令によって実現している．呼び出しブロック名をパスに追加す
るためにこの\bcode{jmp}命令の前に\bcode{block}命令を生成するようにしてい
る．手続き呼び出しの引数は実引数の値を呼び出しの\bcode{jmp}前に
\bcode{load}命令で演算スタックに積んでおき，\bcode{proc}命令の実行後に
\bcode{store}命令でブロック生成時に割り当てられる仮引数に対応する変数に
代入する．手続きが終了し呼び出した番地に戻る\bcode{p\_return}命令では
\bcode{proc}命令で演算スタックに積んでおいた呼び出した\bcode{jmp}命令の
PCを演算スタックから読み出しその番地にシャンプすることで手続きからの戻り
動作を実現する．

一方，関数の振舞いは\bcode{func}命令から\bcode{f\_return}命令までのブロッ
クで記述され，関数からの呼び出した番地への帰り動作と返り値の扱い以外は手
続きと同様に動作する．関数では返り値を扱う必要があるため
\bcode{f\_return}命令で呼び出した番地へ帰る前にload命令で演算スタックに
返り値を積む．この際に積む値は関数の名前自体を変数名とした変数の値とする．
そのため\bcode{func}命令を実行した後関数名を変数名とした変数をalloc命令
によって宣言する．この関数内では関数名自体を局所変数と同様に扱って演算す
ることができる．


\subsection{逆方向実行環境の概要}
\label{sec:4.2}

逆方向の抽象命令セットを\tabref{tab:backwardinstruction}に示す．

\begin{figure}[tb]
\CaptionType{table}
\caption{逆方向の抽象機械命令セット}
\ecaption{instruction of abstract machine for backward}
\label{tab:backwardinstruction}
\begin{center}
\begin{tabular}[t]{|c|c|c|}\hline
番号 & 命令 & 被演算子 \\\hline
1 & \bcode{rjmp} & 0 \\\hline
2 & \bcode{restore} & 変数番地 \\\hline
3 & \bcode{r\_label} & 0 \\\hline
4 & \bcode{par} & \{0,1\} \\\hline
5 & \bcode{r\_alloc} & 変数番地 \\\hline
6 & \bcode{free} & 変数番地 \\\hline
7 & \bcode{r\_proc} & pn \\\hline
8& \bcode{r\_return} &pn \\\hline
9& \bcode{block} & bn \\\hline
10& \bcode{end} & bn \\\hline
11& \bcode{r\_fork} & an \\\hline
12& \bcode{merge} &an \\\hline
13& \bcode{r\_w\_label} & wn \\\hline
14& \bcode{w\_end} & wn \\\hline
15& \bcode{nop} & 0 \\\hline
\end{tabular}
\end{center}
\end{figure}

逆方向の実行では，順方向実行のバイトコードの抽象命令を一対一で変換した逆
方向実行のバイトコードを抽象機械に与え，順方向実行時にスタックに保存した
逆向き実行に必要な情報を用いて順方向の実行を逆向きに辿る実行を行う．
順方向バイトコード系列$s$から逆方向バイトコード系列への変換$i(s)$を
\figref{fig:rulebyte}に示す．

\begin{figure}[tb]
\setbox0\vbox{
\[
  i(s) = \left\{ \begin{array}{ll}
    \epsilon & (s=\epsilon) \\
    i(s')inv(c) & (s=cs')
  \end{array} \right.
\]

\hbox{$inv(\mathsf{store}\ v)= \mathsf{restore}\ v,\ \ \ \ \ \ \ inv(\mathsf{jpc}\ a)=\mathsf{r\_label}\ 0 $}

\hbox{$inv(\mathsf{jmp}\ a)=\mathsf{r\_label}\ 0,\ \ \ \ \ \ \ \ \ inv(\mathsf{label}\ n)=\mathsf{rjmp}\ n$}

\hbox{$inv(\mathsf{par}\ 0)=\mathsf{par}\ 1,\ \ \ \ \ \ \ \ \ \ \ \ \ \ inv(par\ 1)=par\ 0$}

\hbox{$inv(\mathsf{alloc}\ v)=\mathsf{r\_free}\ v,\ \ \ \ \ \ \ \ inv(\mathsf{free}\ v)=\mathsf{r\_alloc}\ v$}

\hbox{$inv(\mathsf{fork}\ an)=merge\ an,\ \ \ \ \ inv(\mathsf{merge}\ an)=r\_fork\ an$}

\hbox{$inv(\mathsf{block}\ bn)=end\ bn,\ \ \ \ \ \ \ \ \ inv(\mathsf{end}\ bn)=block\ bn$}

\hbox{$inv(\mathsf{proc}\ pn)=\mathsf{r\_return}\ pn,\ \ \ inv(\mathsf{p\_return}\ pn)=\mathsf{r\_proc}\ pn$}

\hbox{$inv(\mathsf{func}\ fn)=\mathsf{r\_return}\ fn,\ \ inv(\mathsf{f\_return}\ fn)=\mathsf{r\_proc}\ pn$}

\hbox{$inv(\mathsf{w\_label}\ wn)=\mathsf{w\_end}\ wn,\ \ inv(\mathsf{w\_end}\ wn)=\mathsf{r\_w\_label}\ wn$}

\hbox{\|その他の命令cは|$inv(c\ n)=\mathsf{nop}\ 0$\|に変換する．|}
}
\centerline{\fbox{\box0}}
\caption{逆方向バイトコードへの変換規則}
\ecaption{conversion rule for backward bytecode}
\label{fig:rulebyte}
\end{figure}


逆方向の実行に必要な情報はジャンプ履歴，変数更新履歴そして各変数の最後の値であ
る．順方向実行時にジャンプ履歴はラベルスタックに保存し変数更新履歴は値ス
タックに保存し各変数の最後の値は変数テーブルに保存する．各変数の最後に関
しては単純に順方向のfree命令でテーブルに書き込み逆方向のr\_alloc命令でそ
の値を読み込む．


%4.2.1
\subsubsection{ジャンプ履歴の利用}

逆方向の実行ではlabel命令から変換したrjmp命令でラベルスタックに積まれた
ジャンプ履歴を取り出しそのPCにジャンプする．ただしパスとプロセス番号が一
致しているかを確認し一致していない場合実行することができない．その場合こ
のプロセスは待ち状態となり別のプロセスが実行を進めていく．このようにして
順方向の実行で起きたジャンプをちょうど逆順に辿る実行を行う．

%4.2.2
\subsubsection{変数更新履歴の利用}

逆方向の実行ではstore命令から変換したrestore命令で値スタックに積まれた変
数の値を取り出しその値を被演算子と現在のパスが表す番地に保存することで順
方向の変数の更新とは逆順に変数の値を戻す実行を行う．

\subsubsection{手続き，関数の逆方向の振る舞い}

手続き，および関数は逆方向の命令では両方ともにr\_proc命令から始まり，
r\_return命令で終わる．逆方向実行では呼び出しを行った命令のPCや手続き，
関数が終了して戻るPCはジャンプ履歴としてラベルスタックに保存されているた
め，r\_procはパスを追加する機能を持ったr\_label命令，r\_return命令はパス
を削除する機能を持ったrjmp命令として動作することで逆方向の手続き，関数の
実行を実現している．

\subsubsection{並列ブロックの逆方向の振る舞い}

逆方向実行ではr\_fork命令で並列ブロックを生成するために並列テーブルの参
照する際，並列テーブルに保存されている各ブロックの終わりのPCおよび始まり
のPCと対応する逆方向実行のバイトコードのPCをそれぞれ始まりのPCと終わりの
PCとする．これによって順方向実行で生成した際と同じプロセス番号で逆方向実
行でも並列プロセスを生成することができる．ネスト構造を含んでいても必ず同
じプロセス番号のプロセスがネストするプロセスを生成するため順方向実行と逆
方向実行のネストの構造は一致する．

%3.3
\subsection{可逆抽象機械}
\label{sec:format}

プログラムを抽象機械のバイトコードに変換する．このバイトコードをプロセスにおいて固有の演算用のスタックとプロセス間で共有の共有変数スタックを持つ抽象機械によって実行することでプログラムに書かれたステートメントを順方向に実行する．順方向実行時に逆向き実行に必要な情報を保存する．

%3.3.1
\subsubsection{振舞い定義}

変数集合$X$上の可逆抽象機械の振舞いを以下のように定義する．
順方向のバイトコードと逆方向のバイトコードを持ち、並列ブロックを実行する際には
複数の抽象機械を生成(fork動作)し，並列ブロックがすべて終了した際に
制御をマージ(merge動作)する．

%\begin{defn}
可逆抽象機械の動作は，$(PC,PC',w,\delta,\chi,\rho,\xi,\sigma)$で表す．
\begin{itemize}
\item $PC$: プログラムカウンター
\item $PC'$: 一つ前に実行したバイトコードのプログラムカウンター
\item $w\in(\mathbb{Z}\cup\mathbb{A})^\ast$: ローカルスタック
\item $\delta\in\mathbb{L}^\ast$: 動的コンテクスト
\item $\chi\in \mathbb{L}\cup\{\bot\}$: 並列コンテクスト
\item $\rho\in(\mathbb{A}\times\mathbb{P})^\ast$: ラベルスタック
\item $\xi\in(\mathbb{Z}\times\mathbb{P})^\ast$: 値スタック
\item $\sigma\in X\times\mathbb{L}^\ast\rightarrow\mathbb{Z}$: 変数値	
\end{itemize}
ここで、$\mathbb{P}$はプロセスIdの集合，$\mathbb{Z}$は整数の集合、
$\mathbb{A}$はプログラム番地の集合を示す．
%\end{defn}

$\delta$は、抽象機械が変数を参照するブロック名のパスを示し，$\chi$は抽象
機械が子プロセスを持つ場合，その並列ブロックの名前を保持する。子プロセス
を持たない場合$\bot$となる．$\rho$、$\xi$、$\sigma$はすべての抽象機械で
共有する．

プロセスIdは，プロセスが新たに生成されるごとにユニークなIdが生成される．
以下では，プロセスIdは自然数の系列$\mathbb{N}^+$で表し，プロセスId $p$が
$i$番目に生成したプロセスを$p\cdot i$で表す．

\subsubsection{順方向の振舞い定義}

プロセスId $p$ の抽象機械のバイトコード$(b,o)$の振舞い
$\xrightarrow{b,o}_{p}$を以下に示す．

\begin{list}{$\bullet$}{}
\item \bcode{ipush}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{ipush},n)}_p$\newline
\qquad$(P+1,P,w\cdot n,\delta,\chi,\rho,\xi,\sigma)$\newline
\bcode{ipush}はスタックのトップに被演算子の即値をプッシュする．
\item \bcode{load}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{load},x)}_p$\newline
\qquad$(P+1,P,w\cdot lup(\sigma,x,\delta),\delta,\chi,\rho,\xi,\sigma)$\newline
\bcode{load}は被演算子の変数番地の値を読み出し，その値をスタックトップにプッシュする．
\item \bcode{store}:\\
$(P,P',w\cdot n,\delta,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{store},x)}_p$\newline
\qquad$(P+1,P,w,\delta,\chi,\rho\cdot(p,\sigma(x)),\xi,sto(\sigma,x,\delta,n))$\newline
\bcode{store}はスタックトップの値をポップし被演算子の変数番地$x$ に保存する．
値スタックに保存する前の変数番地の値を値スタック$\rho$にプッシュする．
\item  \bcode{jpc}:\\
$(P,P',w\cdot c,\rho,\xi,\sigma)\xrightarrow{(\mathsf{jpc},a)}_p$\newline
\qquad\qquad$\begin{cases}
(a,P,w,\rho,\xi,\sigma) & \mbox{if $c=1$}\\
(P+1,P,w,\rho,\xi,\sigma) & \mbox{otherwise}
\end{cases}$
\newline
\bcode{jpc}はスタックトップから値をポップしその値が１ならば被演算子のジャンプ先$a$を次のPCの値とする． 
\item \bcode{jmp}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{jmp},a}_p$\newline
\qquad$(a,P,w,\delta,\chi,\rho,\xi,\sigma)$\newline
\bcode{jmp}は無条件で被演算子のジャンプ先PCの値を次のPCの値とする．
\item 
$(P,P',w\cdot \delta,\chi,n'\cdot n,\rho,\xi,\sigma)\xrightarrow{(\mathsf{op},m)}_p$\newline
\qquad $(P+1,P,w\cdot op(m)(n',n),\delta,\chi,\rho,\xi,\sigma)$\newline
\bcode{op}はスタックトップから値を二回ポップしその二つの値に対して被演算子の演算番号$m$（0,1,2,3,4）に対してそれぞれ$op(m)$（+,-,$\times$,>,==）の演算を行う．
\item \bcode{label}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{label},N)}_p$\newline
\qquad$(P+1,P,w,\delta,\chi,\rho,\xi\cdot(p,P'),\sigma)$\newline
\bcode{label}はラベルスタックに飛び元の番地をプッシュする．
\item \bcode{par}:\\
$(B,0,w,\rho,\xi,\sigma)\xrightarrow{(\mathsf{par},0)}_{p\cdot i}(B+1,B,w,\rho,\xi,\sigma)$\newline
$(E-1,P',w,\rho,\xi,\sigma)\xrightarrow{(\mathsf{par},1)}_{p\cdot i}(E,E-1,w,\rho,\xi,\sigma)$\newline
ここで$(B,E)=T(p)(i)$。
\bcode{par}は親プロセス$p$の$\chi$の名前を持つ並列ブロックテーブルの開始番地から\bcode{par}\ 0を実行し，終了番地において\bcode{par}\ 1を実行する。
\item \bcode{alloc}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{alloc},x)}_p$\newline
\qquad $(P+1,P,w,\delta,\chi,\rho,\xi,\sigma\cup(\delta.x\mapsto 0)$\newline
\bcode{alloc}は変数$x$の領域を$\sigma$に追加する．初期値は0となっている．
\item \bcode{free}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{free},x)}_p$\newline
\qquad $(P+1,P,w,\delta,\chi,\rho,\xi,\sigma-(\delta,x)$\newline
\bcode{free}は変数番地の解放を行う．
\item \bcode{proc}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{proc},pn)}_p$\newline
\qquad $(P+1,P,w\cdot P'+1,\delta\cdot pn,\chi,\rho,\xi\cdot(p,P'),\sigma)$\newline
\bcode{proc}は手続きの始まりを表す．パスにpnを追加しlabel命令と同様にラベルスタックに一つ前のPCをプッシュする．帰り番地を保存するために一つ前のPC+1を演算スタックにプッシュする．
\item \bcode{p\_return}:\\
$(P,P',w\cdot a,\delta\cdot pn,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{p\_return},0)}_p$\newline
\qquad $(a+1,P,\delta,\chi,\rho,\xi,\sigma)$\newline
\bcode{p\_return}は手続きの終了を表す．パスからpnを削除し演算スタックから帰り番地のＰＣをポップしそのPCにジャンプする．
\item \bcode{block}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{block},bn)}_p$\newline
\qquad $(P+1,P,w,\delta\cdot bn,\chi,\rho,\xi,\sigma)$\newline
\bcode{block}はパスにbnを追加する．
\item \bcode{end}:\\
$(P,P',w,\delta\cdot bn,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{end},bn)}_p$\newline
\qquad $(P+1,P,w,\delta,\chi,\rho,\xi,\sigma)$\newline
endはパスからbnを削除する．
\item \bcode{fork}:\\
$(P,P',w,\delta,\bot,\rho,\xi,\sigma)\xrightarrow{(\mathsf{fork},an)}_p$\newline
\qquad $(P'',P,w,\delta,an,\rho,\xi,\sigma)$\newline
ここで、$P''=T(an).last+1$\\
\bcode{fork} anは並列ブロックテーブル$T(an)$に基づいて並行プロセスを生成する．
$T(an)(i)=(B,E)$であるとき、開始命令番地$B$とするバイトコード列を実行する$p\cdot i$をIdとする
$|T(an)|$個の子プロセスを生成して実行する．
\item \bcode{merge}:\\
$(P,P',w,\delta,\chi,\rho,an,\sigma)\xrightarrow{(\mathsf{merge},an)}_p$\newline
\qquad $(P+1,P,w,\delta,\bot,\rho,\bot,\sigma)$\newline
\bcode{merge}命令は子プロセス$p\cdot i$のPCがすべて$T(an)(i)=(B_i,E_i)$の$E_i$となったときに
実行される．
\item \bcode{func}:\\
$(P,P',w\cdot n,\delta,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{func},fn)}_p$\newline
\qquad $(P+1,P,w\cdot P'+1\cdot n,\delta\cdot fn,\chi,\rho,\xi\cdot(P',p),\sigma)$\newline
\bcode{func}は関数の始まりを表す．パスにfnを追加し，\bcode{label}命令と
      同様にラベルスタックに一つ前のPCの値をプッシュする．帰り番地を保存
      するために一つ前のＰＣの値を演算スタックにプッシュする．演算スタッ
      クに既に積まれている実引数の値を演算スタックの一番上に移動させる．
\item \bcode{f\_return}:\\
$(P,P',w\cdot a\cdot r,\delta\cdot pn,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{f\_return},pn)}_p$\newline
\qquad $(a,P,w\cdot r,\delta,\chi,\rho,\xi,\sigma)$\newline
\bcode{f\_return}はパスからpnを削除し局所スタックからスタックトップの一
      つ下にある帰り番地をポップしその番地にジャンプする．
\item \bcode{w\_label}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{w\_label},wn)}_p$\newline
\qquad $(P+1,P,w,\delta\cdot wn,\chi,\rho,\xi\cdot(p,P'),\sigma)$\newline
\bcode{w\_label}はwhileループの開始点であり、パスにwnを追加し一つ前のPCをラベルスタックにプッシュする．
\item \bcode{w\_end}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{w\_end},wn)}_p$\newline
\qquad $(P+1,P,w,\delta',\chi,\rho,\sigma)$\newline
ここで、$\delta'=rm(\delta,wn)$\newline
\bcode{w\_end}はパスからwnを全て削除する．
\item \bcode{nop}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\xrightarrow{(\mathsf{nop},0)}_p$\newline
\qquad $(P+1,P,w,\delta,\chi,\rho,\sigma)$\newline
\bcode{nop}は何も操作を行わない．
\end{list}

\subsubsection{逆方向振舞い定義}

プロセスId $p$ の抽象機械の逆方向のためのバイトコード$(b,o)$の振舞い
$\brightarrow{b,o}_{p}$を以下に示す．

\begin{list}%
 {$\bullet$} %default label
 {} %formatting parameter
 \item \bcode{rjmp}:\\
$(P,P',w,\delta,\chi,\rho,\xi\cdot(p,a),\sigma)\brightarrow{(\mathsf{rjmp},N)}_p$\newline
\qquad$(N+1-a,P,w,\delta,\chi,\rho,\xi,\sigma)$\newline
\bcode{rjmp}はラベルスタックから値をポップし$N+1-a$にジャンプする．
長さ$N$の順方向の実行系列において$a$のアドレスは逆方向では、$N+1-a$となる．
\item \bcode{restore}:\\
$(P,P',w,\delta,\chi,\rho\cdot(p,n),\xi,\sigma)\brightarrow{(\mathsf{restore},x)}_p$\newline
\qquad$(P+1,P,w,\delta,\chi,\rho,\xi,upd(\sigma,\delta,x,n))$\newline
\bcode{restore}は値スタックから値をポップしその値を共有変数スタックの変数番地に格納する．
\item \bcode{r\_label}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\brightarrow{(\mathsf{r\_label})}_p$
\newline
$(P+1,P,w,\delta,\chi,\rho,\xi,\sigma)$\newline
\bcode{r\_label}は\bcode{rjmp}のターゲットとなる．
\item \bcode{par}:\\
$(B,0,w,\rho,\xi,\sigma)\brightarrow{(\mathsf{par},0)}_{p\cdot i}(B+1,B,w,\rho,\xi,\sigma)$\newline
$(E-1,P',w,\rho,\xi,\sigma)\brightarrow{(\mathsf{par},1)}_{p\cdot i}(E,E-1,w,\rho,\xi,\sigma)$\newline
ここで$T(p)(i)=(B',E')$に対して$(B,E)=(N+1-B',N+1-E')$ $r\_fork$によって起動される。
\bcode{par}は親プロセス$p$の$\chi$の名前を持つ並列ブロックテーブルの開始番地から\bcode{par}\ 0を実行し，終了番地において\bcode{par}\ 1を実行する．
\item \bcode{r\_alloc}:\\\relax
[to be filled:逆方向計算の定義を修正]
\item \bcode{free}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\brightarrow{(\mathsf{free},x)}_p$\newline
\qquad $(P+1,P,w,\delta,\chi,\rho,\xi,\sigma-(\delta,x)$\newline
\bcode{free}は変数番地の解放を行う．
\item \bcode{r\_proc}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\brightarrow{(\mathsf{r\_proc},pn)}_p$\newline
\qquad $(P+1,P,w,\delta\cdot pn,\chi,\rho,\xi,\sigma)$\newline
手続きの始まりを表す．パスにpnを追加する．
\item \bcode{r\_return}:\\
$(P,P',w,\delta\cdot pn,\chi,\rho,\xi,\sigma)\brightarrow{(\mathsf{r\_return},pn)}_p$\newline
\qquad $(P+1,P,w,\delta\cdot pn,\chi,\rho,\xi,\sigma)$\newline
手続きの終了を表す．パスからpnを削除する．
\item \bcode{block}:\\
$(P,P',w,\delta,\chi,\rho,\xi,\sigma)\brightarrow{(\mathsf{block},bn)}_p$\newline
\qquad $(P+1,P,w,\delta\cdot bn,\chi,\rho,\xi,\sigma)$\newline
\bcode{block}はパスにbnを追加する．
\item \bcode{end}:\\
$(P,P',w,\delta\cdot bn,\chi,\rho,\xi,\sigma)\brightarrow{(\mathsf{end},bn)}_p$\newline
\qquad $(P+1,P,w,\delta,\chi,\rho,\xi,\sigma)$\newline
endはパスからbnを削除する．
\item \bcode{r\_fork}:\\
$(P,P',w,\delta,\bot,\rho,\bot,\sigma)\xrightarrow{(\mathsf{fork},an)}_p$\newline
\qquad $(P'',P,w,\delta,an,\rho,\xi,\sigma)$\newline
ここで、$P''=T(an)^{-1}_N.last+1$\\
\bcode{r\_fork} anは並列ブロックテーブル$T(an)$を逆方向のために変換した
$T(an)^{-1}_N$に基づいて子プロセスを生成する。ここで、$T(an)^{-1}_N$は以下のように
得られる．
$T(an)(i)=(B,E)$であるとき$T(an)^{-1}_N(i)=(N+1-E,N+1-B)$.
$T(an)^{-1}_N$はanに属するプログラムブロックの開始命令番地と終了命令番地を入れかえて
得られる並行ブロックテーブルである．
\item \bcode{merge}:\\
$(P,P',w,\delta,\chi,\rho,an,\sigma)\brightarrow{(\mathsf{merge},an)}_p$\newline
\qquad $(P+1,P,w,\delta,\bot,\rho,an,\sigma)$\newline
\bcode{merge}命令は子プロセス$p\cdot i$のPCがすべて$T(an)^{-1}_N(i)=(B_i,E_i)$の$E_i$となったときに実行される．
\item \bcode{r\_w\_label}:
\item \bcode{r\_w\_end}:
\end{list}



\subsubsection{バイトコードの例}

\begin{figure}[tb]
\setbox0\vbox{
\hbox{\|1 : block  b1         41: op     4|}
\hbox{\|2 : alloc  0          42: jpc    44|}
\hbox{\|3 : alloc  1          43: jmp    61|}
\hbox{\|4 : alloc  2          44: label  80|}
\hbox{\|5 : jmp    66         45: load   0|}
\hbox{\|6 : proc   p1         46: ipush  0|}
\hbox{\|7 : fork   a1         47: op     3|}
\hbox{\|8 : par    0          48: jpc    50|}
\hbox{\|9 : block  b2         49: jmp    56|}
\hbox{\|10: w_label w1        50: label  80|}
\hbox{\|11: load   1          51: load   0|}
\hbox{\|12: ipush  1          52: ipush  1|}
\hbox{\|13: op     4          53: op     2|}
\hbox{\|14: jpc    16         54: store  0|}
\hbox{\|15: jmp    33         55: jmp    59|}
\hbox{\|16: label  80         56: label  80|}
\hbox{\|17: load   0          57: ipush  0|}
\hbox{\|18: ipush  0          58: store 2|}
\hbox{\|19: op     3          59: label  80|}
\hbox{\|20: jpc    22         60: jmp    38|}
\hbox{\|21: jmp    28         61: w_end  w2|}
\hbox{\|22: label  80         62: end    b3|}
\hbox{\|23: load   0          63: par    1|}
\hbox{\|24: ipush  1          64: merge a1|}
\hbox{\|25: op     2          65: p_return p1|}
\hbox{\|26: store  0          66: label  80|}
\hbox{\|27: jmp    31         67: ipush  3|}
\hbox{\|28: label  80         68: store  0|}
\hbox{\|29: ipush  0          69: ipush  1|}
\hbox{\|30: store  1          70: store  1|}
\hbox{\|31: label  80         71: ipush  1|}
\hbox{\|32: jmp    10         72: store  2|}
\hbox{\|33: w_end  w1         73: block  c1|}
\hbox{\|34: end    b2         74: jmp    6|}
\hbox{\|35: par    1          75: label  80|}
\hbox{\|36 : par   0          76: end    c1|}
\hbox{\|37: block  b3         77: free   2|}
\hbox{\|38: w_label w2        78: free   1|}
\hbox{\|39: load   2          79: free   0|}
\hbox{\|40: ipush  1          80: end    b1|}
}
\centerline{\fbox{\box0}}
\caption{プログラム例: 順方向実行のバイトコード}
\ecaption{sample program: a byte code of forward execution}
\label{fig:bytecode}
\end{figure}


\begin{figure}[tb]
\setbox0\vbox{
\hbox{\|1 : block  b1         41: nop    0|}
\hbox{\|2 : r_alloc 0         42: nop    0|}
\hbox{\|3 : r_alloc 1         43: w_end  w2|}
\hbox{\|4 : r_alloc 2         44: block  b3|}
\hbox{\|5 : block  c1         45: par    1|}
\hbox{\|6 : rjmp   0          46: par    0|}
\hbox{\|7 : r_label 0         47: end   b2|}
\hbox{\|8 : end    c1         48: r_w_label w1|}
\hbox{\|9 : restore 2         49: r_label 0|}
\hbox{\|10: nop     0         50: rjmp    0|}
\hbox{\|11: restore 1         51: restore 1|}
\hbox{\|12: nop     0         52: nop     0|}
\hbox{\|13: restore  2        53: rjmp    0|}
\hbox{\|14: nop     0         54: r_label 0|}
\hbox{\|15: rjmp    0         55: restore 0|}
\hbox{\|16: r_proc  p1        56: nop     0|}
\hbox{\|17: r_fork  a1        57: nop     0|}
\hbox{\|18: par     0         58: nop     0|}
\hbox{\|19: block   3         59: rjmp    0|}
\hbox{\|20: r_w_label 22      60: r_label 0|}
\hbox{\|21: r_label  0        61: r_label 0|}
\hbox{\|22: rjmp     0        62: nop     0|}
\hbox{\|23: resotre  2        63: nop     0|}
\hbox{\|24: nop      0        64: nop     0|}
\hbox{\|25: rjmp     0        65: rjmp    0|}
\hbox{\|26: r_label  0        66: r_label 0|}
\hbox{\|27: restore  0        67: r_label 0|}
\hbox{\|28: nop      0        68: nop     0|}
\hbox{\|29: nop      0        69: nop     0|}
\hbox{\|30: nop      0        70: nop     0|}
\hbox{\|31: rjmp     0        71: w_end   w1|}
\hbox{\|32: r_label  0        72: end     b1|}
\hbox{\|33: r_label  0        73: par     1|}
\hbox{\|34: nop      0        74: merge   a1|} 
\hbox{\|35: nop      0        75: r_return p1|}
\hbox{\|36: nop      0        76: r_label 0|}
\hbox{\|37: rjmp     0        77: free    2|}
\hbox{\|38: r_label  0        78: free    1|}
\hbox{\|39: r_label  0        79: free    0|}
\hbox{\|40: nop      0        80: end     b1|}
}
\centerline{\fbox{\box0}}
\caption{プログラム例: 逆方向実行のバイトコード}
\ecaption{sample program: a byte code of backward execution}
\label{fig:backward}
\end{figure}



\figref{fig:sample}を順方向実行のバイトコードに変換すると\figref{fig:bytecode}になる．左端の数字はPC（プログラムカウンタ）を表し（命令，被演算子）というように抽象機械命令が表示されている．

\figref{fig:bytecode}の抽象機械命令を一対一で変換し順序を反転させたものが\figref{fig:backward}の逆方向実行のバイトコードである．これを用いて順方向実行の実行を逆に辿る実行を行う．

\subsection{プログラム例}

\figref{fig:bytecode}は\figref{fig:sample}を順方向実行のバイトコードに変換したものであり，\figref{fig:backward}は\figref{fig:bytecode}を命令を一対一で置換し順番を反転させた逆方向実行のバイトコードである．\figref{fig:bytecode}のPC=17からPC=20の実行とPC=45からPC=48の実行がそれぞれ\figref{fig:sample}の9行目，18行目に対応している．この部分がseats=1の状態で並列実行され同時に実行されるとseats=-1になる不正な動作が起こる可能性がある．

この実行を\figref{fig:backward}で逆方向に辿ることを考える．ラベルスタック，値スタックを使って逆方向実行を進めていくと順方向実行のバイトコードのPC=26（store命令）を変換したPC=55のrestore命令もしくは順方向実行のバイトコードのPC=54（store命令）を変換したPC=27のrestore命令においてseatsの値が-1から0に戻される．これによってseatsが0より大きいという条件判定でseats=seats-1の処理をしたにもかかわらずseatsの値がすでに0になってしまっていて不正に1引いてしまった部分がどこであるかを特定することができる．

%5
\section{実行環境の実現}

\subsection{抽象機械の実装}


本研究では並列プログラムの実行を行うため抽象機械をPythonのmultiprocessingモジュールを用いて実装している．並列プロセスの生成はfork命令を実行する際に並列テーブルを参照し必要な数だけmultiprocessingモジュールのprocess関数を用いて生成する．このとき並列プロセスを生成したプロセスは抽象機械の実行としては待ち状態になり生成したプロセスの番号を保持しそれらが終了しているかどうかを監視するプロセスとして動作する．監視プロセスが自分の生成したプロセスが終了した（PCが終了番地に達した）と判定した場合multiprocessingモジュールのterminate関数を用いてそのプロセスを終了させる．そのようにしてすべての生成したプロセスが終了したと判定された場合監視を終了し抽象機械の実行を行うプロセスに戻る．


\subsection{実行例}
本研究で実装した可逆実行環境の実行例を示す．\figref{fig:target}の対象プログラムを順方向実行しその実行を逆に辿る実行をすることを考える．\figref{fig:target}のプログラムは3の階乗を計算するプログラムで，関数bug\_fact(x)は再帰的に計算を行いxの階乗を返す関数である．しかしbug\_fact(x)は並列に二つのプロセスを実行し一つのプロセスは順当に階乗の計算を再帰的に行う．もう一つのプロセスは順当に行う階乗の計算を妨害するように仮引数xの値をいずれかのタイミングで1引くプロセスとなっている．この妨害プロセスがどのタイミングで行われるかによって階乗計算の結果と再帰する数及び並列プロセスの生成数が異なる例となっている．



\begin{figure}[tb]
\setbox0\vbox{
\hbox{\|begin b1|}
\hbox{\|    var x;|}
\hbox{\|    var y;|}
\hbox{\|    func f1 bug_fact(x) is|}
\hbox{\|        par a1|}
\hbox{\|            begin b2|}
\hbox{\|                var z;|}
\hbox{\|                if (x>0) then|}
\hbox{\|                    begin b3|}
\hbox{\|                        z=x-1;|}
\hbox{\|                        fact = x*{c1 fact(z)}|}
\hbox{\|                    end|}
\hbox{\|                else|}
\hbox{\|                    fact=1|}
\hbox{\|                fi|}
\hbox{\|                remove z;|}
\hbox{\|            end|}
\hbox{\|        |$||$\|  begin b4|}
\hbox{\|                if (x>1) then|}
\hbox{\|                    x = x-1|}
\hbox{\|                else|}
\hbox{\|                    skip|}
\hbox{\|                fi|}
\hbox{\|            end|}
\hbox{\|        rap|}
\hbox{\|    return|}
\hbox{\|    x=3;|}
\hbox{\|    y={c2 bug_fact(x)}|}
\hbox{\|    remove y;|}
\hbox{\|    remove x;|}
\hbox{\|end|}
}
\centerline{\fbox{\box0}}
\caption{対象プログラム（bug\_fact）}
\ecaption{a target program(bug\_fact)}
\label{fig:target}
\end{figure}


\begin{figure}[tb]
\setbox0\vbox{
\hbox{\|1 : block  b1         39: end    b2|}
\hbox{\|2 : alloc  0          40: par    1|}
\hbox{\|3 : alloc  1          41: par    0|}
\hbox{\|4 : jmp    64         42: block  b4|}
\hbox{\|5 : func   f1         43: load   0|}
\hbox{\|6 : alloc  2          44: ipush  1|}
\hbox{\|7 : alloc  0          45: op     3|}
\hbox{\|8 : store  0          46: jpc    48|}
\hbox{\|9 : fork   a1         47: jmp    54|}
\hbox{\|10: par     0         48: label  75|}
\hbox{\|11: block  b2         49: load   0|}
\hbox{\|12: alloc  3          50: ipush  1|}
\hbox{\|13: load   0          51: op     2|}
\hbox{\|14: ipush  0          52: store  0|}
\hbox{\|15: op     3          53: jmp    56|}
\hbox{\|16: jpc    18         54: label  75|}
\hbox{\|17: jmp    34         55: nop    0|}
\hbox{\|18: label  75         56: label  75|}
\hbox{\|19: block  b3         57: end    b4|}
\hbox{\|20: load   0          58: par    1|}
\hbox{\|21: ipush  1          59: merge  a1|}
\hbox{\|22: op     2          60: load   2|}
\hbox{\|23: store  3          61: free   2|}
\hbox{\|24: load   0          62: free   2|}
\hbox{\|25: load   3          63: f_return f1|}
\hbox{\|26: block  c1         64: label  75|}
\hbox{\|27: jmp    5          65: ipush  3|}
\hbox{\|28: label  75         66: store  0|}
\hbox{\|29: end    c1         67: load   0|}
\hbox{\|30: op     1          68: block  c2|}
\hbox{\|31: store  2          69: jmp    5|}
\hbox{\|32: end    b3         70: label  75|}
\hbox{\|33: jmp    37         71: end    c2|}
\hbox{\|34: label  75         72: store  1|}
\hbox{\|35: ipush  1          73: free   1|}
\hbox{\|36: store  2          74: free   0|}
\hbox{\|37: label  75         75: end    b1|}
\hbox{\|38: free    3         |}

}
\centerline{\fbox{\box0}}
\caption{順方向実行のバイトコード（bug\_fact）}
\ecaption{a byte code of forward execution(bug\_fact)}
\label{fig:forwardfact}
\end{figure}


このプログラムをコンパイラに与えることでそれぞれのステートメントを抽象機械命令に変換し順方向実行のバイトコードを生成する．\figref{fig:forwardfact}が生成した順方向実行のバイトコードである．このバイトコードを抽象機械に与えることで順方向の実行を行う．

\begin{figure}[tb]
\setbox0\vbox{
\hbox{\|0 0.b1.E|}
\hbox{\|0 0.f1.c2.b1.E|}
\hbox{\|3 0.2.b4.f1.c2.b1.E|}
\hbox{\|0 0.1.b3.b2.f1.c2.b1.E|}
\hbox{\|0 0.1.f1.c1.b3.b2.f1.c2.b1.E|}
\hbox{\|2 0.1.2.b4.f1.c1.b3.b2.f1.c2.b1.E|}
\hbox{\|0 0.1.1.b3.b2.f1.c1.b3.b2.f1.c2.b1.E|}
\hbox{\|0 0.1.1.f1.c1.b3.b2.f1.c1.b3.b2.f1.c2.b1.E|}
\hbox{\|0 0.1.1.1.b3.b2.f1.c1.b3.b2.f1.c1.b3.b2.f1.c2.b1.E|}
\hbox{\|0 0.1.1.1.f1.c1.b3.b2.f1.c1.b3.b2.f1.c1.b3.b2.f1.c2.b1.E|}
\hbox{\|0 0.1.1.1.1.b2.f1.c1.b3.b2.f1.c1.b3.b2.f1.c1.b3.b2.f1.c2.b1.E|}
\hbox{\|0 0.1.1.1.b3.b2.f1.c1.b3.b2.f1.c1.b3.b2.f1.c2.b1.E|}
\hbox{\|0 0.1.1.b3.b2.f1.c1.b3.b2.f1.c2.b1.E|}
\hbox{\|0 0.1.b3.b2.f1.c2.b1.E|}
\hbox{\|0 0.b1.E|}
}
\centerline{\fbox{\box0}}
\caption{値スタック（bug\_fact）}
\ecaption{value stack(bug\_fact)}
\label{fig:value}
\end{figure}

\begin{figure}[tb]
\setbox0\vbox{
\hbox{\|72 0|}
\hbox{\|7 0|}
\hbox{\|30 0.2|}
\hbox{\|60 0.1|}
\hbox{\|23 0.2|}
\hbox{\|49 0.1|}
\hbox{\|60 0.1.1|}
\hbox{\|30 0.1.2|}
\hbox{\|23 0.1.2|}
\hbox{\|49 0.1.1|}
\hbox{\|60 0.1.1.1|}
\hbox{\|29 0.1.1.2|}
\hbox{\|21 0.1.1.2|}
\hbox{\|49 0.1.1.1|}
\hbox{\|59 0.1.1.1.1|}
\hbox{\|29 0.1.1.1.2|}
\hbox{\|21 0.1.1.1.2|}
\hbox{\|40 0.1.1.1.1|}
\hbox{\|13 0.1.1.1|}
\hbox{\|43 0.1.1.1|}
\hbox{\|13 0.1.1|}
\hbox{\|43 0.1.1|}
\hbox{\|13 0.1|}
\hbox{\|43 0.1|}
\hbox{\|13 0|}
}
\centerline{\fbox{\box0}}
\caption{ラベルスタック（bug\_fact）}
\ecaption{label stack(bug\_fact)}
\label{fig:label}
\end{figure}



\figref{fig:forwardfact}を抽象機械で実行すると\figref{fig:value}，\figref{fig:label}のように値スタック，ラベルスタックに逆方向実行に必要な情報が保存される．\figref{fig:value}は値スタックを示し，一行のうち左側に変数の値，右側にstore命令を行ったプロセスとパスが保存されている．例えば一行目の(0 0.b1.E)はプロセス0のパスb1の状態で何らかの変数の値を更新しその変数のそれまでの値が0であったことを示す．プロセス0.1，プロセス0.2は並列で動作しているプロセスだが三行目，四行目を見るとその実行順がプロセス0.2，プロセス0.1の順番で実行されたことが保存されている．
\figref{fig:label}はラベルスタックを示し，一行のうち左側にジャンプしたPCの値，右側にlabel命令を行ったプロセスIDが保存されている．例えば一行目の(72 0.b1.E)はプロセス0がPC=72の命令からlabel命令にジャンプしてきたことを示す．特に条件分岐について条件判定を行わずともどこから分岐（ジャンプ）したかという情報が残されているためラベルスタックを見るだけでどのように分岐したかがわかる．






\begin{figure}[tb]
\setbox0\vbox{
\hbox{\|1 : block   b1         39: rjmp    0|}
\hbox{\|2 : r_alloc 0          40: restore 2|}
\hbox{\|3 : r_alloc 1          41: nop     0|}
\hbox{\|4 : restore 1          42: rjmp    0|}
\hbox{\|5 : block   c2         43: r_label 0|}
\hbox{\|6 : rjmp    0          44: block   b3|}
\hbox{\|7 : r_label 0          45: restore 2|}
\hbox{\|8 : end     c2         46: nop     0|}
\hbox{\|9 : nop     0          47: block   c1|}
\hbox{\|10: resotre 0          48: rjmp    0|}
\hbox{\|11: nop     0          49: r_label 0|}
\hbox{\|12: rjmp    0          50:  end    c1|}
\hbox{\|13: r_proc  f1         51: nop     0|}
\hbox{\|14: r_alloc 2          52: nop     0|}
\hbox{\|15: r_alloc 0          53: restore 3|}
\hbox{\|16: nop     0          54: nop     0|}
\hbox{\|17: r_fork  a1         55: nop     0|}
\hbox{\|18: par     0          56: nop     0|}
\hbox{\|19: block   b4         57: end     b3|}
\hbox{\|20: rjmp    0          58: rjmp    0|}
\hbox{\|21: nop     0          59: r_label 0|}
\hbox{\|22: rjmp    0          60: r_label 0|}
\hbox{\|23: r_label 0          61: nop     0|}
\hbox{\|24: restore 0          62: nop     0|}
\hbox{\|25: nop     0          63: nop     0|}
\hbox{\|26: nop     0          64: free    3|}
\hbox{\|27: nop     0          65: end     b2|}
\hbox{\|28: rjmp    0          66: par     1|}
\hbox{\|29: r_label 0          67: merge   a1|}
\hbox{\|30: r_label 0          68: restore 0|}
\hbox{\|31: nop     0          69: free    0|}
\hbox{\|32: nop     0          70: free    2|}
\hbox{\|33: nop     0          71: r_return f1|}
\hbox{\|34: end     b4         72: r_label 0|}
\hbox{\|35: par     1          73: free    1|}
\hbox{\|36: par     0          74: free    0|}
\hbox{\|37: block   b2         75: end     b1|}
\hbox{\|38: r_alloc 3         |}

}
\centerline{\fbox{\box0}}
\caption{逆方向実行のバイトコード（bug\_fact）}
\ecaption{a byte code of backward execution(bug\_fact)}
\label{fig:backwardfact}
\end{figure}


\figref{fig:forwardfact}の抽象命令を一対一で変換し順番を反転させたものが\figref{fig:backwardfact}である．変数の宣言，更新，解放やジャンプやパスの追加，削除そして並列ブロックに関わる命令以外は全てnopに変換されている．これは本研究における逆方向実行は変数の値を元に戻すということを主目的としているためである．そのため演算スタックを元に戻すという動作が存在しない．

\figref{fig:backwardfact}の逆方向実行バイトコードと\figref{fig:value}，\figref{fig:label}の逆方向実行に必要な情報を用いて順方向の実行を逆方向に辿る．\figref{fig:value}と\figref{fig:label}の下から保存した情報を消費していく．それぞれrestore命令とrjmp命令においてパスが一致しているか否かを判定し一致している場合左側の値を消費して変数の値を戻したりジャンプを逆方向に辿っていく．パスが一致していない場合そのプロセスの実行は待ち状態になり別プロセスが実行を進める．このようにして順方向で実行した順番とちょうど逆順に変数の更新と逆方向ジャンプを行う．



%2
\section{関連研究}

並列プログラムに対する逆方向実行について，先行研究\cite{HIY18,H20}によって提案されている手法について説明する．先行研究\cite{HIY18,H20}によって提案されている手法では，whileループやif文，手続き呼び出しのブロックそして並列ブロックを持つような単純なプログラムを対象としている．この対象プログラムに対して逆方向実行に必要な情報を残すための処理を行う．この処理をAnnotationと呼び対象プログラムにAnnotationを適用し逆方向実行に必要な情報を残せる形式にしたプログラムをAnnotatedプログラムと呼ぶ．Annotatedプログラムを実行することによってこのプログラム自体に逆方向実行に必要な情報が書き込まれる．実行されたAnnotatedプログラムをif文やwhile文，手続き呼び出しそして並列ブロックの構造は保持したままでその他の記述順を反転させることでInvertedプログラムが生成され，これを実行することで対象プログラムの実行を逆方向に辿ることができる．

\subsection{対象プログラムの定義}

\begin{figure}[tb]
\setbox0\vbox{
\hbox{$P ::= \epsilon\ |\ S |\ P;P |\ P\ par\ P$}
\hbox{$S ::= skip | X = E\ pa | if\ In\ B\ then\ P\ else\ Q\ end\ pa|$}
\hbox{$\ \ \ \ \ \ \ \ while\ Wn\ B\ do\ P\ end\ pa | $}
\hbox{$\ \ \ \ \ \ \ \ begin\ Bn\ BB\ end |\ call\ Cn\ n\ pa|$}
\hbox{$\ \ \ \ \ \ \ \ runc\ Cn\ P\ end$}
\hbox{$BB\ ::=\ DV\ DP\ P;\ RP\ RV$}
\hbox{$E::=X |\ n |\ (E)|\ E\ Op\ E$}
\hbox{$B::=T|\ F|\ \lnot B |\ (B)|\ E\ ==\ E |\ E > E|\ B \land B$}
\hbox{$DV\ ::= \epsilon |\ var\ X=E\ pa;\ DV$}
\hbox{$DP\ ::= \epsilon |\ proc\ Pn\ n\ is\ P\ end\ pa;\ DP$}
\hbox{$RV\ ::=\epsilon |\  remove\ X=E\ pa;\ RV$}
\hbox{$RP\ ::= \epsilon |\ remove\ Pn\ n\ is\ P\ end\ pa;\ RP$}
}
\centerline{\fbox{\box0}}
\caption{対象プログラムの定義}
\ecaption{definition of language}
\label{fig:Hdef}
\end{figure}


逆方向実行を行う対象のプログラムに対する定義を示す．対象とするプログラムはwhileループ，if文，手続き呼び出しのブロックそして並列ブロックを持つようなプログラムであり\figref{fig:Hdef}のように定義する．



\subsection{Annotatedプログラム}

\figref{fig:Hdef}で定義された対象プログラムに対してAnnotationを行い，Annotatedプログラムを生成しそれを実行する．

\begin{figure}[tb]
\begin{center}
\begin{tabular}{c}
\begin{minipage}[t]{0.5\columnwidth}
\footnotesize
\setbox0\vbox{
\hbox{\|begin b1|}
\hbox{\|   proc p1 fib is|}
\hbox{\|   begin b2|}
\hbox{\|      var T = 0 b2;|}
\hbox{\|      if i1 (N-2 > 0) then|}
\hbox{\|         T = F + S b2;|}
\hbox{\|         F = S b2;|}
\hbox{\|         S = T b2;|}
\hbox{\|         N = N - 1 b2;|}
\hbox{\|       call c2 fib b2;|}
\hbox{\|    end b2|}
\hbox{\|    remove T = 0 b2;|}
\hbox{\|  end|}
\hbox{\|  b1|}
\hbox{\|  call c1fib is P b1;|}
\hbox{\|  remove p1 fib is P b1;|}
\hbox{\|end|}
}
\centerline{\fbox{\box0}}
\caption{対象プログラム}
\ecaption{Original Program}
\label{fig:Horiginal}
\end{minipage}

\begin{minipage}[t]{0.5\columnwidth}
\footnotesize
\setbox0\vbox{
\hbox{\|begin b1|}
\hbox{\|   proc p1 fib is|}
\hbox{\|   begin b2|}
\hbox{\|      var T = 0 (b2*b1,A);|}
\hbox{\|      if i1 (N-2 > 0) then|}
\hbox{\|         T = F + S (b2*b1,A);|}
\hbox{\|         F = S (b2*b1,A);|}
\hbox{\|         S = T (b2*b1,A);|}
\hbox{\|         N = N - 1 (b2*b1,A);|}
\hbox{\|       call c2 fib (b2*b1,A);|}
\hbox{\|    end (b2*b1,A)|}
\hbox{\|    remove T = 0 (b2*b1,A);|}
\hbox{\|  end|}
\hbox{\|  (b1,A)|}
\hbox{\|  call c1fib is P (b1,A);|}
\hbox{\|  remove p1 fib is P (b1,A);|}
\hbox{\|end|}
}
\centerline{\fbox{\box0}}
\caption{Annotated プログラム}
\ecaption{Annotated Program}
\label{fig:Hannotated}
\end{minipage}
\end{tabular}
\end{center}
\end{figure}

\figref{fig:Horiginal}のプログラムから\figref{fig:Hannotated}のプログラムがAnnotatedプログラムの変換規則に則って生成される．この時，手続きp1内のステートメントはブロックb1内のブロックb2に存在しているのでこれらのステートメントのパスはb2*b1に変換する．Annotatedプログラムにはそれぞれのステートメントに識別子を書き込むためにスタックAを書き加えている．


\begin{figure}[tb]
\setbox0\vbox{
\hbox{\|begin c1:c2:b2|}
\hbox{\|   var T = 0 (c1:c2:b2*b1,[7]);|}
\hbox{\|   if c1:c2:i1 (N-2 > 0) then|}
\hbox{\|     T = F + S (c1:c2:b2*b1,[8]);|}
\hbox{\|     F = S (c1:c2:b2*b1,[9]);|}
\hbox{\|     S = T (c1:c2:b2*b1,[10]);|}
\hbox{\|     N = N - 1 (c1:c2:b2*b1,[11]);|}
\hbox{\|     call c2 fib (c1:c2:b2*b1,[15]);|}
\hbox{\|  end (c1:c2:b2*b1,[16])|}
\hbox{\|  remove T = 0 (c1:c2:b2*b1,[17]);|}
\hbox{\|end|}
}
\centerline{\fbox{\box0}}
\caption{実行されたAnnotatedプログラム\\
（2回目の手続き呼び出し）}
\ecaption{Executed Annotated Program\\
 (second procedure call)}
\label{fig:Hexec}
\end{figure}


\figref{fig:Hannotated}を実行すると\figref{fig:Hexec}のようにプログラム自体にAnnotation及びパスが書き込まれる．\figref{fig:Hexec}は2回目の手続き呼び出しを行ったものであり手続き呼び出しのブロック自体をコピーしそこにAnnotationとパスを書き込んでいる．

ここで変数T=0がvarステートメントで宣言されているが，この変数はc1:c2:b2*b1のTとして扱われる．このようにして変数を宣言する際にパスを要素に組み込むことで局所変数を実現している．

\subsection{Inverted プログラム}
\begin{figure}[tb]
\setbox0\vbox{
\hbox{\|begin c1:c2:b2|}
\hbox{\|   var T = 0 (c1:c2:b2*b1,[17]);|}
\hbox{\|   if c1:c2:i1 (N-2 > 0) then|}
\hbox{\|     call c2 fib (c1:c2:b2*b1,[15]);|}
\hbox{\|     N = N - 1 (c1:c2:b2*b1,[11]);|}
\hbox{\|     S = T (c1:c2:b2*b1,[10]);|}
\hbox{\|     F = S (c1:c2:b2*b1,[9]);|}
\hbox{\|     T = F + S (c1:c2:b2*b1,[8]);|}
\hbox{\|     F = S (c1:c2:b2*b1,[9]);|}
\hbox{\|  end (c1:c2:b2*b1,[16])|}
\hbox{\|  remove T = 0 (c1:c2:b2*b1,[7]);|}
\hbox{\|end|}
}
\centerline{\fbox{\box0}}
\caption{Inverted プログラム\\
（2回目の手続き呼び出しの部分）}
\ecaption{Inverted Program\\
 (part of second procedure call)}
\label{fig:Hinvprogram}
\end{figure}


実行されたパス及びAnnotationに逆向き実行に必要な情報が残されており実行されたAnnotated Programから変換されたInverted Programを実行することでAnnotated Programの実行を逆順に辿る実行を行う．


\figref{fig:Hexec}の実行されたAnnotatedプログラムをInverted Programへ変換したものが\figref{fig:Hinvprogram}である．Annotationの数字がそのステートメントが実行された順番を表していてAnnotationに書かれている最大の値から始めて一つずつAnnotationに書かれている数字を遡っていくことでAnnotated Programで行った順方向の実行を逆方向に辿る実行を行うことができる．


%6
\section{おわりに}


\begin{thebibliography}{10}
\bibitem{Janus1} 1
\bibitem{Janus2} 2
\bibitem{RFUN} 3
\bibitem{HIY18} 4
\bibitem{H20} 5
\bibitem{RC2020} 6
\end{thebibliography}

\end{document}
